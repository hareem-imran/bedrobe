function initCycleCarousel() { jQuery(".cycle-gallery").scrollAbsoluteGallery({ mask: ".mask", slider: ".slideset", slides: ".slide", btnPrev: "a.btn-prev", btnNext: "a.btn-next", pagerLinks: ".pagination li", stretchSlideToMask: !0, pauseOnHover: !1, maskAutoSize: !0, autoRotation: !0, switchTime: 3e3, animSpeed: 500 }) } jQuery(function () { initCycleCarousel() }), function (t) { function e(e) { this.options = t.extend({ activeClass: "active", mask: "div.slides-mask", slider: ">ul", slides: ">li", btnPrev: ".btn-prev", btnNext: ".btn-next", pagerLinks: "ul.pager > li", generatePagination: !1, pagerList: "<ul>", pagerListItem: '<li><a href="#"></a></li>', pagerListItemText: "a", galleryReadyClass: "gallery-js-ready", currentNumber: "span.current-num", totalNumber: "span.total-num", maskAutoSize: !1, autoRotation: !1, pauseOnHover: !1, stretchSlideToMask: !1, switchTime: 3e3, animSpeed: 500, handleTouch: !0, swipeThreshold: 15, vertical: !1 }, e), this.init() } e.prototype = { init: function () { this.options.holder && (this.findElements(), this.attachEvents(), this.makeCallback("onInit", this)) }, findElements: function () { this.holder = t(this.options.holder).addClass(this.options.galleryReadyClass), this.mask = this.holder.find(this.options.mask), this.slider = this.mask.find(this.options.slider), this.slides = this.slider.find(this.options.slides), this.btnPrev = this.holder.find(this.options.btnPrev), this.btnNext = this.holder.find(this.options.btnNext), this.currentNumber = this.holder.find(this.options.currentNumber), this.totalNumber = this.holder.find(this.options.totalNumber), "string" == typeof this.options.generatePagination ? this.pagerLinks = this.buildPagination() : this.pagerLinks = this.holder.find(this.options.pagerLinks), this.sizeProperty = this.options.vertical ? "height" : "width", this.positionProperty = this.options.vertical ? "top" : "left", this.animProperty = this.options.vertical ? "marginTop" : "marginLeft", this.slideSize = this.slides[this.sizeProperty](), this.currentIndex = 0, this.prevIndex = 0, this.options.maskAutoSize = this.options.vertical ? !1 : this.options.maskAutoSize, this.options.vertical && this.mask.css({ height: this.slides.innerHeight() }), this.options.maskAutoSize && this.mask.css({ height: this.slider.height() }), this.slider.css({ position: "relative", height: this.options.vertical ? this.slideSize * this.slides.length : "100%" }), this.slides.css({ position: "absolute" }).css(this.positionProperty, -9999).eq(this.currentIndex).css(this.positionProperty, 0), this.refreshState() }, buildPagination: function () { var e = t(); if (this.pagerHolder || (this.pagerHolder = this.holder.find(this.options.generatePagination)), this.pagerHolder.length) { this.pagerHolder.empty(), this.pagerList = t(this.options.pagerList).appendTo(this.pagerHolder); for (var i = 0; i < this.slides.length; i++) t(this.options.pagerListItem).appendTo(this.pagerList).find(this.options.pagerListItemText).text(i + 1); e = this.pagerList.children() } return e }, attachEvents: function () { var e = this; this.btnPrev.length && (this.btnPrevHandler = function (t) { t.preventDefault(), e.prevSlide() }, this.btnPrev.click(this.btnPrevHandler)), this.btnNext.length && (this.btnNextHandler = function (t) { t.preventDefault(), e.nextSlide() }, this.btnNext.click(this.btnNextHandler)), this.pagerLinks.length && (this.pagerLinksHandler = function (t) { t.preventDefault(), e.numSlide(e.pagerLinks.index(t.currentTarget)) }, this.pagerLinks.click(this.pagerLinksHandler)), this.options.pauseOnHover && (this.hoverHandler = function () { clearTimeout(e.timer) }, this.leaveHandler = function () { e.autoRotate() }, this.holder.bind({ mouseenter: this.hoverHandler, mouseleave: this.leaveHandler })), this.resizeHandler = function () { e.animating || (e.options.stretchSlideToMask && e.resizeSlides(), e.resizeHolder(), e.setSlidesPosition(e.currentIndex)) }, t(window).bind("load resize orientationchange", this.resizeHandler), e.options.stretchSlideToMask && e.resizeSlides(), this.options.handleTouch && window.Hammer && this.mask.length && this.slides.length > 1 && i && (this.swipeHandler = new Hammer.Manager(this.mask[0]), this.swipeHandler.add(new Hammer.Pan({ direction: e.options.vertical ? Hammer.DIRECTION_VERTICAL : Hammer.DIRECTION_HORIZONTAL, threshold: e.options.swipeThreshold })), this.swipeHandler.on("panstart", function () { e.animating ? e.swipeHandler.stop() : clearTimeout(e.timer) }).on("panmove", function (t) { e.swipeOffset = -e.slideSize + t[e.options.vertical ? "deltaY" : "deltaX"], e.slider.css(e.animProperty, e.swipeOffset), clearTimeout(e.timer) }).on("panend", function (t) { if (t.distance > e.options.swipeThreshold) t.offsetDirection === Hammer.DIRECTION_RIGHT || t.offsetDirection === Hammer.DIRECTION_DOWN ? e.nextSlide() : e.prevSlide(); else { var i = {}; i[e.animProperty] = -e.slideSize, e.slider.animate(i, { duration: e.options.animSpeed }), e.autoRotate() } e.swipeOffset = 0 })), this.autoRotate(), this.resizeHolder(), this.setSlidesPosition(this.currentIndex) }, resizeSlides: function () { this.slideSize = this.mask[this.options.vertical ? "height" : "width"](), this.slides.css(this.sizeProperty, this.slideSize) }, resizeHolder: function () { this.options.maskAutoSize && this.mask.css({ height: this.slides.eq(this.currentIndex).outerHeight(!0) }) }, prevSlide: function () { !this.animating && this.slides.length > 1 && (this.direction = -1, this.prevIndex = this.currentIndex, this.currentIndex > 0 ? this.currentIndex-- : this.currentIndex = this.slides.length - 1, this.switchSlide()) }, nextSlide: function (t) { !this.animating && this.slides.length > 1 && (this.direction = 1, this.prevIndex = this.currentIndex, this.currentIndex < this.slides.length - 1 ? this.currentIndex++ : this.currentIndex = 0, this.switchSlide()) }, numSlide: function (t) { !this.animating && this.currentIndex !== t && this.slides.length > 1 && (this.direction = t > this.currentIndex ? 1 : -1, this.prevIndex = this.currentIndex, this.currentIndex = t, this.switchSlide()) }, preparePosition: function () { this.setSlidesPosition(this.prevIndex, this.direction < 0 ? this.currentIndex : null, this.direction > 0 ? this.currentIndex : null, this.direction) }, setSlidesPosition: function (t, e, i, n) { if (this.slides.length > 1) { var s = "number" == typeof e ? e : t > 0 ? t - 1 : this.slides.length - 1, r = "number" == typeof i ? i : t < this.slides.length - 1 ? t + 1 : 0; if (this.slider.css(this.animProperty, this.swipeOffset ? this.swipeOffset : -this.slideSize), this.slides.css(this.positionProperty, -9999).eq(t).css(this.positionProperty, this.slideSize), s === r && "number" == typeof n) { var o = n > 0 ? 2 * this.slideSize : 0; this.slides.eq(r).css(this.positionProperty, o) } else this.slides.eq(s).css(this.positionProperty, 0), this.slides.eq(r).css(this.positionProperty, 2 * this.slideSize) } }, switchSlide: function () { var t = this, e = (this.slides.eq(this.prevIndex), this.slides.eq(this.currentIndex)); this.animating = !0, this.options.maskAutoSize && this.mask.animate({ height: e.outerHeight(!0) }, { duration: this.options.animSpeed }); var i = {}; i[this.animProperty] = this.direction > 0 ? 2 * -this.slideSize : 0, this.preparePosition(), this.slider.animate(i, { duration: this.options.animSpeed, complete: function () { t.setSlidesPosition(t.currentIndex), t.animating = !1, t.autoRotate(), t.makeCallback("onChange", t) } }), this.refreshState(), this.makeCallback("onBeforeChange", this) }, refreshState: function (t) { this.slides.removeClass(this.options.activeClass).eq(this.currentIndex).addClass(this.options.activeClass), this.pagerLinks.removeClass(this.options.activeClass).eq(this.currentIndex).addClass(this.options.activeClass), this.currentNumber.html(this.currentIndex + 1), this.totalNumber.html(this.slides.length), this.holder.toggleClass("not-enough-slides", 1 === this.slides.length) }, autoRotate: function () { var t = this; clearTimeout(this.timer), this.options.autoRotation && (this.timer = setTimeout(function () { t.nextSlide() }, this.options.switchTime)) }, makeCallback: function (t) { if ("function" == typeof this.options[t]) { var e = Array.prototype.slice.call(arguments); e.shift(), this.options[t].apply(this, e) } }, destroy: function () { this.btnPrev.unbind("click", this.btnPrevHandler), this.btnNext.unbind("click", this.btnNextHandler), this.pagerLinks.unbind("click", this.pagerLinksHandler), this.holder.unbind("mouseenter", this.hoverHandler), this.holder.unbind("mouseleave", this.leaveHandler), t(window).unbind("load resize orientationchange", this.resizeHandler), clearTimeout(this.timer), this.swipeHandler && this.swipeHandler.destroy(), this.holder.removeClass(this.options.galleryReadyClass), this.slider.add(this.slides).removeAttr("style"), "string" == typeof this.options.generatePagination && this.pagerHolder.empty() } }; var i = /Windows Phone/.test(navigator.userAgent) || "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch; t.fn.scrollAbsoluteGallery = function (i) { return this.each(function () { t(this).data("ScrollAbsoluteGallery", new e(t.extend(i, { holder: this }))) }) } }(jQuery), Object.create && !function (t, e, i, n) { "use strict"; function s(t, e, i) { return setTimeout(l(t, i), e) } function r(t, e, i) { return Array.isArray(t) ? (o(t, i[e], i), !0) : !1 } function o(t, e, i) { var s; if (t) if (t.forEach) t.forEach(e, i); else if (t.length !== n) for (s = 0; s < t.length;) e.call(i, t[s], s, t), s++; else for (s in t) t.hasOwnProperty(s) && e.call(i, t[s], s, t) } function h(t, e, i) { for (var s = Object.keys(e), r = 0; r < s.length;) (!i || i && t[s[r]] === n) && (t[s[r]] = e[s[r]]), r++; return t } function a(t, e) { return h(t, e, !0) } function u(t, e, i) { var n, s = e.prototype; n = t.prototype = Object.create(s), n.constructor = t, n._super = s, i && h(n, i) } function l(t, e) { return function () { return t.apply(e, arguments) } } function c(t, e) { return typeof t == lt ? t.apply(e ? e[0] || n : n, e) : t } function p(t, e) { return t === n ? e : t } function d(t, e, i) { o(g(e), function (e) { t.addEventListener(e, i, !1) }) } function f(t, e, i) { o(g(e), function (e) { t.removeEventListener(e, i, !1) }) } function m(t, e) { for (; t;) { if (t == e) return !0; t = t.parentNode } return !1 } function v(t, e) { return t.indexOf(e) > -1 } function g(t) { return t.trim().split(/\s+/g) } function y(t, e, i) { if (t.indexOf && !i) return t.indexOf(e); for (var n = 0; n < t.length;) { if (i && t[n][i] == e || !i && t[n] === e) return n; n++ } return -1 } function T(t) { return Array.prototype.slice.call(t, 0) } function I(t, e, i) { for (var n = [], s = [], r = 0; r < t.length;) { var o = e ? t[r][e] : t[r]; y(s, o) < 0 && n.push(t[r]), s[r] = o, r++ } return i && (n = e ? n.sort(function (t, i) { return t[e] > i[e] }) : n.sort()), n } function S(t, e) { for (var i, s, r = e[0].toUpperCase() + e.slice(1), o = 0; o < at.length;) { if (i = at[o], s = i ? i + r : e, s in t) return s; o++ } return n } function b() { return ft++ } function E(t) { var e = t.ownerDocument; return e.defaultView || e.parentWindow } function x(t, e) { var i = this; this.manager = t, this.callback = e, this.element = t.element, this.target = t.options.inputTarget, this.domHandler = function (e) { c(t.options.enable, [t]) && i.handler(e) }, this.init() } function w(t) { var e, i = t.options.inputClass; return new (e = i ? i : gt ? q : yt ? F : vt ? j : M)(t, P) } function P(t, e, i) { var n = i.pointers.length, s = i.changedPointers.length, r = e & xt && n - s === 0, o = e & (Pt | kt) && n - s === 0; i.isFirst = !!r, i.isFinal = !!o, r && (t.session = {}), i.eventType = e, k(t, i), t.emit("hammer.input", i), t.recognize(i), t.session.prevInput = i } function k(t, e) { var i = t.session, n = e.pointers, s = n.length; i.firstInput || (i.firstInput = C(e)), s > 1 && !i.firstMultiple ? i.firstMultiple = C(e) : 1 === s && (i.firstMultiple = !1); var r = i.firstInput, o = i.firstMultiple, h = o ? o.center : r.center, a = e.center = A(n); e.timeStamp = dt(), e.deltaTime = e.timeStamp - r.timeStamp, e.angle = _(h, a), e.distance = D(h, a), H(i, e), e.offsetDirection = R(e.deltaX, e.deltaY), e.scale = o ? O(o.pointers, n) : 1, e.rotation = o ? L(o.pointers, n) : 0, z(i, e); var u = t.element; m(e.srcEvent.target, u) && (u = e.srcEvent.target), e.target = u } function H(t, e) { var i = e.center, n = t.offsetDelta || {}, s = t.prevDelta || {}, r = t.prevInput || {}; (e.eventType === xt || r.eventType === Pt) && (s = t.prevDelta = { x: r.deltaX || 0, y: r.deltaY || 0 }, n = t.offsetDelta = { x: i.x, y: i.y }), e.deltaX = s.x + (i.x - n.x), e.deltaY = s.y + (i.y - n.y) } function z(t, e) { var i, s, r, o, h = t.lastInterval || e, a = e.timeStamp - h.timeStamp; if (e.eventType != kt && (a > Et || h.velocity === n)) { var u = h.deltaX - e.deltaX, l = h.deltaY - e.deltaY, c = N(a, u, l); s = c.x, r = c.y, i = pt(c.x) > pt(c.y) ? c.x : c.y, o = R(u, l), t.lastInterval = e } else i = h.velocity, s = h.velocityX, r = h.velocityY, o = h.direction; e.velocity = i, e.velocityX = s, e.velocityY = r, e.direction = o } function C(t) { for (var e = [], i = 0; i < t.pointers.length;) e[i] = { clientX: ct(t.pointers[i].clientX), clientY: ct(t.pointers[i].clientY) }, i++; return { timeStamp: dt(), pointers: e, center: A(e), deltaX: t.deltaX, deltaY: t.deltaY } } function A(t) { var e = t.length; if (1 === e) return { x: ct(t[0].clientX), y: ct(t[0].clientY) }; for (var i = 0, n = 0, s = 0; e > s;) i += t[s].clientX, n += t[s].clientY, s++; return { x: ct(i / e), y: ct(n / e) } } function N(t, e, i) { return { x: e / t || 0, y: i / t || 0 } } function R(t, e) { return t === e ? Ht : pt(t) >= pt(e) ? t > 0 ? zt : Ct : e > 0 ? At : Nt } function D(t, e, i) { i || (i = Lt); var n = e[i[0]] - t[i[0]], s = e[i[1]] - t[i[1]]; return Math.sqrt(n * n + s * s) } function _(t, e, i) { i || (i = Lt); var n = e[i[0]] - t[i[0]], s = e[i[1]] - t[i[1]]; return 180 * Math.atan2(s, n) / Math.PI } function L(t, e) { return _(e[1], e[0], Ot) - _(t[1], t[0], Ot) } function O(t, e) { return D(e[0], e[1], Ot) / D(t[0], t[1], Ot) } function M() { this.evEl = qt, this.evWin = Xt, this.allow = !0, this.pressed = !1, x.apply(this, arguments) } function q() { this.evEl = Wt, this.evWin = jt, x.apply(this, arguments), this.store = this.manager.session.pointerEvents = [] } function X() { this.evTarget = Ut, this.evWin = Vt, this.started = !1, x.apply(this, arguments) } function Y(t, e) { var i = T(t.touches), n = T(t.changedTouches); return e & (Pt | kt) && (i = I(i.concat(n), "identifier", !0)), [i, n] } function F() { this.evTarget = Bt, this.targetIds = {}, x.apply(this, arguments) } function W(t, e) { var i = T(t.touches), n = this.targetIds; if (e & (xt | wt) && 1 === i.length) return n[i[0].identifier] = !0, [i, i]; var s, r, o = T(t.changedTouches), h = [], a = this.target; if (r = i.filter(function (t) { return m(t.target, a) }), e === xt) for (s = 0; s < r.length;) n[r[s].identifier] = !0, s++; for (s = 0; s < o.length;) n[o[s].identifier] && h.push(o[s]), e & (Pt | kt) && delete n[o[s].identifier], s++; return h.length ? [I(r.concat(h), "identifier", !0), h] : void 0 } function j() { x.apply(this, arguments); var t = l(this.handler, this); this.touch = new F(this.manager, t), this.mouse = new M(this.manager, t) } function G(t, e) { this.manager = t, this.set(e) } function U(t) { if (v(t, ee)) return ee; var e = v(t, ie), i = v(t, ne); return e && i ? ie + " " + ne : e || i ? e ? ie : ne : v(t, te) ? te : $t } function V(t) { this.id = b(), this.manager = null, this.options = a(t || {}, this.defaults), this.options.enable = p(this.options.enable, !0), this.state = se, this.simultaneous = {}, this.requireFail = [] } function Z(t) { return t & ue ? "cancel" : t & he ? "end" : t & oe ? "move" : t & re ? "start" : "" } function B(t) { return t == Nt ? "down" : t == At ? "up" : t == zt ? "left" : t == Ct ? "right" : "" } function Q(t, e) { var i = e.manager; return i ? i.get(t) : t } function J() { V.apply(this, arguments) } function K() { J.apply(this, arguments), this.pX = null, this.pY = null } function $() { J.apply(this, arguments) } function tt() { V.apply(this, arguments), this._timer = null, this._input = null } function et() { J.apply(this, arguments) } function it() { J.apply(this, arguments) } function nt() { V.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0 } function st(t, e) { return e = e || {}, e.recognizers = p(e.recognizers, st.defaults.preset), new rt(t, e) } function rt(t, e) { e = e || {}, this.options = a(e, st.defaults), this.options.inputTarget = this.options.inputTarget || t, this.handlers = {}, this.session = {}, this.recognizers = [], this.element = t, this.input = w(this), this.touchAction = new G(this, this.options.touchAction), ot(this, !0), o(e.recognizers, function (t) { var e = this.add(new t[0](t[1])); t[2] && e.recognizeWith(t[2]), t[3] && e.requireFailure(t[3]) }, this) } function ot(t, e) { var i = t.element; o(t.options.cssProps, function (t, n) { i.style[S(i.style, n)] = e ? t : "" }) } function ht(t, i) { var n = e.createEvent("Event"); n.initEvent(t, !0, !0), n.gesture = i, i.target.dispatchEvent(n) } var at = ["", "webkit", "moz", "MS", "ms", "o"], ut = e.createElement("div"), lt = "function", ct = Math.round, pt = Math.abs, dt = Date.now, ft = 1, mt = /mobile|tablet|ip(ad|hone|od)|android/i, vt = "ontouchstart" in t, gt = S(t, "PointerEvent") !== n, yt = vt && mt.test(navigator.userAgent), Tt = "touch", It = "pen", St = "mouse", bt = "kinect", Et = 25, xt = 1, wt = 2, Pt = 4, kt = 8, Ht = 1, zt = 2, Ct = 4, At = 8, Nt = 16, Rt = zt | Ct, Dt = At | Nt, _t = Rt | Dt, Lt = ["x", "y"], Ot = ["clientX", "clientY"]; x.prototype = { handler: function () { }, init: function () { this.evEl && d(this.element, this.evEl, this.domHandler), this.evTarget && d(this.target, this.evTarget, this.domHandler), this.evWin && d(E(this.element), this.evWin, this.domHandler) }, destroy: function () { this.evEl && f(this.element, this.evEl, this.domHandler), this.evTarget && f(this.target, this.evTarget, this.domHandler), this.evWin && f(E(this.element), this.evWin, this.domHandler) } }; var Mt = { mousedown: xt, mousemove: wt, mouseup: Pt }, qt = "mousedown", Xt = "mousemove mouseup"; u(M, x, { handler: function (t) { var e = Mt[t.type]; e & xt && 0 === t.button && (this.pressed = !0), e & wt && 1 !== t.which && (e = Pt), this.pressed && this.allow && (e & Pt && (this.pressed = !1), this.callback(this.manager, e, { pointers: [t], changedPointers: [t], pointerType: St, srcEvent: t })) } }); var Yt = { pointerdown: xt, pointermove: wt, pointerup: Pt, pointercancel: kt, pointerout: kt }, Ft = { 2: Tt, 3: It, 4: St, 5: bt }, Wt = "pointerdown", jt = "pointermove pointerup pointercancel"; t.MSPointerEvent && (Wt = "MSPointerDown", jt = "MSPointerMove MSPointerUp MSPointerCancel"), u(q, x, { handler: function (t) { var e = this.store, i = !1, n = t.type.toLowerCase().replace("ms", ""), s = Yt[n], r = Ft[t.pointerType] || t.pointerType, o = r == Tt, h = y(e, t.pointerId, "pointerId"); s & xt && (0 === t.button || o) ? 0 > h && (e.push(t), h = e.length - 1) : s & (Pt | kt) && (i = !0), 0 > h || (e[h] = t, this.callback(this.manager, s, { pointers: e, changedPointers: [t], pointerType: r, srcEvent: t }), i && e.splice(h, 1)) } }); var Gt = { touchstart: xt, touchmove: wt, touchend: Pt, touchcancel: kt }, Ut = "touchstart", Vt = "touchstart touchmove touchend touchcancel"; u(X, x, { handler: function (t) { var e = Gt[t.type]; if (e === xt && (this.started = !0), this.started) { var i = Y.call(this, t, e); e & (Pt | kt) && i[0].length - i[1].length === 0 && (this.started = !1), this.callback(this.manager, e, { pointers: i[0], changedPointers: i[1], pointerType: Tt, srcEvent: t }) } } }); var Zt = { touchstart: xt, touchmove: wt, touchend: Pt, touchcancel: kt }, Bt = "touchstart touchmove touchend touchcancel"; u(F, x, { handler: function (t) { var e = Zt[t.type], i = W.call(this, t, e); i && this.callback(this.manager, e, { pointers: i[0], changedPointers: i[1], pointerType: Tt, srcEvent: t }) } }), u(j, x, { handler: function (t, e, i) { var n = i.pointerType == Tt, s = i.pointerType == St; if (n) this.mouse.allow = !1; else if (s && !this.mouse.allow) return; e & (Pt | kt) && (this.mouse.allow = !0), this.callback(t, e, i) }, destroy: function () { this.touch.destroy(), this.mouse.destroy() } }); var Qt = S(ut.style, "touchAction"), Jt = Qt !== n, Kt = "compute", $t = "auto", te = "manipulation", ee = "none", ie = "pan-x", ne = "pan-y"; G.prototype = { set: function (t) { t == Kt && (t = this.compute()), Jt && (this.manager.element.style[Qt] = t), this.actions = t.toLowerCase().trim() }, update: function () { this.set(this.manager.options.touchAction) }, compute: function () { var t = []; return o(this.manager.recognizers, function (e) { c(e.options.enable, [e]) && (t = t.concat(e.getTouchAction())) }), U(t.join(" ")) }, preventDefaults: function (t) { if (!Jt) { var e = t.srcEvent, i = t.offsetDirection; if (this.manager.session.prevented) return void e.preventDefault(); var n = this.actions, s = v(n, ee), r = v(n, ne), o = v(n, ie); return s || r && i & Rt || o && i & Dt ? this.preventSrc(e) : void 0 } }, preventSrc: function (t) { this.manager.session.prevented = !0, t.preventDefault() } }; var se = 1, re = 2, oe = 4, he = 8, ae = he, ue = 16, le = 32; V.prototype = { defaults: {}, set: function (t) { return h(this.options, t), this.manager && this.manager.touchAction.update(), this }, recognizeWith: function (t) { if (r(t, "recognizeWith", this)) return this; var e = this.simultaneous; return t = Q(t, this), e[t.id] || (e[t.id] = t, t.recognizeWith(this)), this }, dropRecognizeWith: function (t) { return r(t, "dropRecognizeWith", this) ? this : (t = Q(t, this), delete this.simultaneous[t.id], this) }, requireFailure: function (t) { if (r(t, "requireFailure", this)) return this; var e = this.requireFail; return t = Q(t, this), -1 === y(e, t) && (e.push(t), t.requireFailure(this)), this }, dropRequireFailure: function (t) { if (r(t, "dropRequireFailure", this)) return this; t = Q(t, this); var e = y(this.requireFail, t); return e > -1 && this.requireFail.splice(e, 1), this }, hasRequireFailures: function () { return this.requireFail.length > 0 }, canRecognizeWith: function (t) { return !!this.simultaneous[t.id] }, emit: function (t) { function e(e) { i.manager.emit(i.options.event + (e ? Z(n) : ""), t) } var i = this, n = this.state; he > n && e(!0), e(), n >= he && e(!0) }, tryEmit: function (t) { return this.canEmit() ? this.emit(t) : void (this.state = le) }, canEmit: function () { for (var t = 0; t < this.requireFail.length;) { if (!(this.requireFail[t].state & (le | se))) return !1; t++ } return !0 }, recognize: function (t) { var e = h({}, t); return c(this.options.enable, [this, e]) ? (this.state & (ae | ue | le) && (this.state = se), this.state = this.process(e), void (this.state & (re | oe | he | ue) && this.tryEmit(e))) : (this.reset(), void (this.state = le)) }, process: function () { }, getTouchAction: function () { }, reset: function () { } }, u(J, V, { defaults: { pointers: 1 }, attrTest: function (t) { var e = this.options.pointers; return 0 === e || t.pointers.length === e }, process: function (t) { var e = this.state, i = t.eventType, n = e & (re | oe), s = this.attrTest(t); return n && (i & kt || !s) ? e | ue : n || s ? i & Pt ? e | he : e & re ? e | oe : re : le } }), u(K, J, { defaults: { event: "pan", threshold: 10, pointers: 1, direction: _t }, getTouchAction: function () { var t = this.options.direction, e = []; return t & Rt && e.push(ne), t & Dt && e.push(ie), e }, directionTest: function (t) { var e = this.options, i = !0, n = t.distance, s = t.direction, r = t.deltaX, o = t.deltaY; return s & e.direction || (e.direction & Rt ? (s = 0 === r ? Ht : 0 > r ? zt : Ct, i = r != this.pX, n = Math.abs(t.deltaX)) : (s = 0 === o ? Ht : 0 > o ? At : Nt, i = o != this.pY, n = Math.abs(t.deltaY))), t.direction = s, i && n > e.threshold && s & e.direction }, attrTest: function (t) { return J.prototype.attrTest.call(this, t) && (this.state & re || !(this.state & re) && this.directionTest(t)) }, emit: function (t) { this.pX = t.deltaX, this.pY = t.deltaY; var e = B(t.direction); e && this.manager.emit(this.options.event + e, t), this._super.emit.call(this, t) } }), u($, J, { defaults: { event: "pinch", threshold: 0, pointers: 2 }, getTouchAction: function () { return [ee] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.scale - 1) > this.options.threshold || this.state & re) }, emit: function (t) { if (this._super.emit.call(this, t), 1 !== t.scale) { var e = t.scale < 1 ? "in" : "out"; this.manager.emit(this.options.event + e, t) } } }), u(tt, V, { defaults: { event: "press", pointers: 1, time: 500, threshold: 5 }, getTouchAction: function () { return [$t] }, process: function (t) { var e = this.options, i = t.pointers.length === e.pointers, n = t.distance < e.threshold, r = t.deltaTime > e.time; if (this._input = t, !n || !i || t.eventType & (Pt | kt) && !r) this.reset(); else if (t.eventType & xt) this.reset(), this._timer = s(function () { this.state = ae, this.tryEmit() }, e.time, this); else if (t.eventType & Pt) return ae; return le }, reset: function () { clearTimeout(this._timer) }, emit: function (t) { this.state === ae && (t && t.eventType & Pt ? this.manager.emit(this.options.event + "up", t) : (this._input.timeStamp = dt(), this.manager.emit(this.options.event, this._input))) } }), u(et, J, { defaults: { event: "rotate", threshold: 0, pointers: 2 }, getTouchAction: function () { return [ee] }, attrTest: function (t) { return this._super.attrTest.call(this, t) && (Math.abs(t.rotation) > this.options.threshold || this.state & re) } }), u(it, J, { defaults: { event: "swipe", threshold: 10, velocity: .65, direction: Rt | Dt, pointers: 1 }, getTouchAction: function () { return K.prototype.getTouchAction.call(this) }, attrTest: function (t) { var e, i = this.options.direction; return i & (Rt | Dt) ? e = t.velocity : i & Rt ? e = t.velocityX : i & Dt && (e = t.velocityY), this._super.attrTest.call(this, t) && i & t.direction && t.distance > this.options.threshold && pt(e) > this.options.velocity && t.eventType & Pt }, emit: function (t) { var e = B(t.direction); e && this.manager.emit(this.options.event + e, t), this.manager.emit(this.options.event, t) } }), u(nt, V, { defaults: { event: "tap", pointers: 1, taps: 1, interval: 300, time: 250, threshold: 2, posThreshold: 10 }, getTouchAction: function () { return [te] }, process: function (t) { var e = this.options, i = t.pointers.length === e.pointers, n = t.distance < e.threshold, r = t.deltaTime < e.time; if (this.reset(), t.eventType & xt && 0 === this.count) return this.failTimeout(); if (n && r && i) { if (t.eventType != Pt) return this.failTimeout(); var o = this.pTime ? t.timeStamp - this.pTime < e.interval : !0, h = !this.pCenter || D(this.pCenter, t.center) < e.posThreshold; this.pTime = t.timeStamp, this.pCenter = t.center, h && o ? this.count += 1 : this.count = 1, this._input = t; var a = this.count % e.taps; if (0 === a) return this.hasRequireFailures() ? (this._timer = s(function () { this.state = ae, this.tryEmit() }, e.interval, this), re) : ae } return le }, failTimeout: function () { return this._timer = s(function () { this.state = le }, this.options.interval, this), le }, reset: function () { clearTimeout(this._timer) }, emit: function () { this.state == ae && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input)) } }), st.VERSION = "2.0.4", st.defaults = { domEvents: !1, touchAction: Kt, enable: !0, inputTarget: null, inputClass: null, preset: [[et, { enable: !1 }], [$, { enable: !1 }, ["rotate"]], [it, { direction: Rt }], [K, { direction: Rt }, ["swipe"]], [nt], [nt, { event: "doubletap", taps: 2 }, ["tap"]], [tt]], cssProps: { userSelect: "none", touchSelect: "none", touchCallout: "none", contentZooming: "none", userDrag: "none", tapHighlightColor: "rgba(0,0,0,0)" } }; var ce = 1, pe = 2; rt.prototype = { set: function (t) { return h(this.options, t), t.touchAction && this.touchAction.update(), t.inputTarget && (this.input.destroy(), this.input.target = t.inputTarget, this.input.init()), this }, stop: function (t) { this.session.stopped = t ? pe : ce }, recognize: function (t) { var e = this.session; if (!e.stopped) { this.touchAction.preventDefaults(t); var i, n = this.recognizers, s = e.curRecognizer; (!s || s && s.state & ae) && (s = e.curRecognizer = null); for (var r = 0; r < n.length;) i = n[r], e.stopped === pe || s && i != s && !i.canRecognizeWith(s) ? i.reset() : i.recognize(t), !s && i.state & (re | oe | he) && (s = e.curRecognizer = i), r++ } }, get: function (t) { if (t instanceof V) return t; for (var e = this.recognizers, i = 0; i < e.length; i++) if (e[i].options.event == t) return e[i]; return null }, add: function (t) { if (r(t, "add", this)) return this; var e = this.get(t.options.event); return e && this.remove(e), this.recognizers.push(t), t.manager = this, this.touchAction.update(), t }, remove: function (t) { if (r(t, "remove", this)) return this; var e = this.recognizers; return t = this.get(t), e.splice(y(e, t), 1), this.touchAction.update(), this }, on: function (t, e) { var i = this.handlers; return o(g(t), function (t) { i[t] = i[t] || [], i[t].push(e) }), this }, off: function (t, e) { var i = this.handlers; return o(g(t), function (t) { e ? i[t].splice(y(i[t], e), 1) : delete i[t] }), this }, emit: function (t, e) { this.options.domEvents && ht(t, e); var i = this.handlers[t] && this.handlers[t].slice(); if (i && i.length) { e.type = t, e.preventDefault = function () { e.srcEvent.preventDefault() }; for (var n = 0; n < i.length;) i[n](e), n++ } }, destroy: function () { this.element && ot(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null } }, h(st, { INPUT_START: xt, INPUT_MOVE: wt, INPUT_END: Pt, INPUT_CANCEL: kt, STATE_POSSIBLE: se, STATE_BEGAN: re, STATE_CHANGED: oe, STATE_ENDED: he, STATE_RECOGNIZED: ae, STATE_CANCELLED: ue, STATE_FAILED: le, DIRECTION_NONE: Ht, DIRECTION_LEFT: zt, DIRECTION_RIGHT: Ct, DIRECTION_UP: At, DIRECTION_DOWN: Nt, DIRECTION_HORIZONTAL: Rt, DIRECTION_VERTICAL: Dt, DIRECTION_ALL: _t, Manager: rt, Input: x, TouchAction: G, TouchInput: F, MouseInput: M, PointerEventInput: q, TouchMouseInput: j, SingleTouchInput: X, Recognizer: V, AttrRecognizer: J, Tap: nt, Pan: K, Swipe: it, Pinch: $, Rotate: et, Press: tt, on: d, off: f, each: o, merge: a, extend: h, inherit: u, bindFn: l, prefixed: S }), typeof define == lt && define.amd ? define(function () { return st }) : "undefined" != typeof module && module.exports ? module.exports = st : t[i] = st }(window, document, "Hammer");